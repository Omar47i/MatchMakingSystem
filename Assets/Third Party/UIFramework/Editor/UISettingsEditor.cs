using UnityEditor;
using UnityEditorInternal;
using UnityEngine;
using deVoid.UIFramework;
using System;
using System.IO;

[CustomEditor(typeof(UISettings))]
public class UISettingsEditor : Editor
{
    ReorderableList list;
    private void OnEnable()
    {
        list = new ReorderableList(serializedObject, serializedObject.FindProperty("screens"), true, true, true, true);
        list.elementHeight = 20;
        list.drawElementCallback = DrawElement;
        list.drawHeaderCallback = DrawHeader;
        list.onCanRemoveCallback = CanRemove;
    }
    public override void OnInspectorGUI()
    {
        UISettings settings = (target as UISettings);
        //string[] UINamesBefore = new string[settings.screens.Count];
        //for(int i=0;i< UINamesBefore.Length;i++)
        //{
        //    UINamesBefore[i] = settings.screens[i].UIName;
        //}
        base.OnInspectorGUI();
        serializedObject.Update();
        list.DoLayoutList();
        serializedObject.ApplyModifiedProperties();
        //string[] UINamesAfter = new string[settings.screens.Count];
        //for (int i = 0; i < UINamesAfter.Length; i++)
        //{
        //    UINamesAfter[i] = settings.screens[i].UIName;
        //}
        //if(NamesChnaged(UINamesBefore,UINamesAfter))
        //{
        //    Debug.Log("Names Changed!");
        //}
        if (GUILayout.Button("Update UIId Enum"))
        {
            UpdateUIWindowsEnumValues();
        }
    }

    private bool NamesChnaged(string[] UINamesBefore, string[] UINamesAfter)
    {
        if (UINamesBefore.Length != UINamesAfter.Length) return true;
        for (int i = 0; i < UINamesBefore.Length; i++)
            if (UINamesBefore[i] != UINamesAfter[i]) return true;
        return false;
    }

    private bool CanRemove(ReorderableList list)
    {
        if (list.count == 1)
            return false;
        return true;
    }
    private void DrawElement(Rect rect, int index, bool isActive, bool isFocused)
    {
        var serialzedUIData = list.serializedProperty.GetArrayElementAtIndex(index);
        serialzedUIData.FindPropertyRelative("ScreenId").stringValue = EditorGUI.TextField(new Rect(rect.x, rect.y, rect.width / 2, rect.height), serialzedUIData.FindPropertyRelative("ScreenId").stringValue);//
        EditorGUI.ObjectField(new Rect(rect.x + rect.width / 2, rect.y, rect.width / 2, rect.height), serialzedUIData.FindPropertyRelative("Prefab"), GUIContent.none);
    }
    private void DrawHeader(Rect rect)
    {
        EditorGUI.LabelField(rect, "Screens");
    }
    private void UpdateUIWindowsEnumValues()
    {
        UISettings settings = (target as UISettings);
        string[] UINames = new string[settings.screens.Count];
        for (int i = 0; i < UINames.Length; i++)
        {
            UINames[i] = settings.screens[i].ScreenId;
        }
        string fileDir = "Assets/Third Party/UIFramework/Internal/";
        string filePathAndName = fileDir + "ScreenId.cs";
        DirectoryInfo direInfo = new DirectoryInfo(fileDir);
        if (!direInfo.Exists)
            direInfo.Create();
        using (StreamWriter streamWriter = new StreamWriter(filePathAndName))
        {
            streamWriter.WriteLine("//DON'T modify or delete this file. This file is autogenerated and used by deVoid UIFramework");
            streamWriter.WriteLine("namespace deVoid.UIFramework");
            streamWriter.WriteLine("{");
            streamWriter.WriteLine("\tpublic enum ScreenId");
            streamWriter.WriteLine("\t{");
            for (int i = 0; i < UINames.Length; i++)
            {
                streamWriter.WriteLine("\t\t" + UINames[i] + ",");
            }
            streamWriter.WriteLine("\t}");
            streamWriter.WriteLine("}");
        }
        AssetDatabase.Refresh();
    }
}
